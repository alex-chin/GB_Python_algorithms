"""
1. Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах
в рамках первых трех уроков. Проанализировать результат и определить программы с наиболее эффективным
использованием памяти.
Примечание: По аналогии с эмпирической оценкой алгоритмов идеальным решением будет:
a. выбрать хорошую задачу, которую имеет смысл оценивать по памяти;
b. написать 3 варианта кода (один у вас уже есть);
проанализировать 3 варианта и выбрать оптимальный;

c. результаты анализа (количество занятой памяти в вашей среде разработки) вставить в виде комментариев
в файл с кодом. Не забудьте указать версию и разрядность вашей ОС и интерпретатора Python;
d. написать общий вывод: какой из трёх вариантов лучше и почему.
Надеемся, что вы не испортили программы, добавив в них множество sys.getsizeof после каждой переменной,
а проявили творчество, фантазию и создали универсальный код для замера памяти.

########## выбрано задание N2 урока 3
2. Во втором массиве сохранить индексы четных элементов первого массива. Например, если дан массив со значениями
8, 3, 15, 6, 4, 2, второй массив надо заполнить значениями 0, 3, 4, 5 (помните, что индексация начинается с нуля),
т. к. именно в этих позициях первого массива стоят четные числа. """

import sys
import random

print(sys.version, sys.platform)


def get_size(object):
    print(f'Объект: {type(object)}, память(байт): {sys.getsizeof(object)}')


array1 = tuple([random.randint(0, 100) for _ in range(50)])
get_size(array1)

# 3 вариант - кортеж
# Объект: <class 'tuple'>, память(байт): 448

# 2 вариант - список
# array1 = [random.randint(0, 100) for _ in range(50)]
# Объект: <class 'list'>, память(байт): 528

# 1 вариант - множество
# array1 = set([random.randint(0, 100) for _ in range(50)])
# Объект: <class 'set'>, память(байт): 2272

array2 = []
for idx, item in enumerate(array1):
    if item % 2 == 0:
        array2.append(idx)
print(array1)
print(array2)

# При анализе кода наиболее оптимальным является использование кортежей (tuple) для
# представления массива, который в течение исполнения кода не изменяется
# для храненения 50 целых чисел в этом случае используется всего 528 байт
# для сравнения множество требует 2272 байт - почти в пять раз больше
